# Name of your application. Used to uniquely configure containers.
service: homechat

# Name of the container image.
image: kebabmane/homechat

# Deploy to these servers.
servers:
  web:
    # Replace with your actual server IPs or hostnames
    # Examples for different cloud providers:
    # AWS: ec2-xxx-xxx-xxx-xxx.compute-1.amazonaws.com
    # GCP: x.x.x.x (Compute Engine IP) 
    # DigitalOcean: your-droplet-ip
    # Vultr: your-vultr-ip
    # Hetzner: your-hetzner-ip
    - REPLACE_WITH_YOUR_SERVER_IP
  
  # Optional: Separate job processing servers for high-traffic deployments
  # Uncomment and configure if you need dedicated background job servers
  # job:
  #   hosts:
  #     - REPLACE_WITH_YOUR_JOB_SERVER_IP
  #   cmd: bin/jobs
  #   env:
  #     clear:
  #       SOLID_QUEUE_IN_PUMA: false

# Enable SSL auto certification via Let's Encrypt
# This automatically handles SSL certificates for your domain
proxy:
  ssl: true
  host: REPLACE_WITH_YOUR_DOMAIN  # e.g., chat.yourdomain.com
  # For custom SSL certificates, see: https://kamal-deploy.org/docs/configuration/proxy/

# Credentials for your image host.
registry:
  # GitHub Container Registry (recommended for public/private repos)
  server: ghcr.io
  username: kebabmane
  
  # Alternatives for different registries:
  # Docker Hub (default): leave server commented out
  # AWS ECR: server: xxxxxxxxxxxx.dkr.ecr.region.amazonaws.com
  # GCP Artifact Registry: server: region-docker.pkg.dev/project-id/repository
  # DigitalOcean: server: registry.digitalocean.com/your-registry
  
  # Always use an access token rather than real password when possible.
  password:
    - KAMAL_REGISTRY_PASSWORD

# Inject ENV variables into containers (secrets come from .kamal/secrets).
env:
  secret:
    - RAILS_MASTER_KEY
    # Optional: Add API tokens for HomeChat integrations
    # - HOMECHAT_API_TOKEN
  clear:
    # Production environment
    RAILS_ENV: production
    RAILS_SERVE_STATIC_FILES: true
    RAILS_LOG_TO_STDOUT: true
    
    # HomeChat specific settings
    ENABLE_INTEGRATIONS: true
    AUTO_CREATE_API_TOKEN: false  # Set to true for auto-generated tokens
    HOME_ASSISTANT_INTEGRATION: true
    
    # Background job processing configuration
    # Run the Solid Queue Supervisor inside the web server's Puma process to do jobs.
    # When you start using multiple servers, you should split out job processing to a dedicated machine.
    SOLID_QUEUE_IN_PUMA: true

    # Set number of processes dedicated to Solid Queue (default: 1)
    # JOB_CONCURRENCY: 3

    # Performance tuning - adjust based on your server specs
    # Set number of cores available to the application on each server (default: 1).
    WEB_CONCURRENCY: 2
    
    # Database configuration (using SQLite by default)
    # For external database servers, uncomment and configure:
    # DB_HOST: your-database-server
    # Use homechat-db for a db accessory server on same machine via local kamal docker network.
    
    # Logging configuration
    RAILS_LOG_LEVEL: info
    # Use 'debug' for troubleshooting: RAILS_LOG_LEVEL: debug

# Aliases are triggered with "bin/kamal <alias>". You can overwrite arguments on invocation:
# "bin/kamal logs -r job" will tail logs from the first server in the job section.
aliases:
  console: app exec --interactive --reuse "bin/rails console"
  shell: app exec --interactive --reuse "bash"
  logs: app logs -f
  dbc: app exec --interactive --reuse "bin/rails dbconsole"


# Use persistent storage volumes for database and uploaded files.
# These volumes persist data across deployments and container restarts.
volumes:
  - "homechat_storage:/rails/storage"   # File uploads and Active Storage
  - "homechat_data:/rails/db"          # SQLite database files
  
# IMPORTANT: For production, consider:
# 1. Regular backups of these volumes
# 2. Using cloud storage for uploads (S3, GCS, etc.)
# 3. External database for high-traffic deployments


# Bridge fingerprinted assets, like JS and CSS, between versions to avoid
# hitting 404 on in-flight requests. Combines all files from new and old
# version inside the asset_path.
asset_path: /rails/public/assets

# Configure the image builder.
builder:
  # Build for the target server architecture (usually amd64 for cloud servers)
  arch: amd64
  
  # For faster builds on different architectures, use a remote builder:
  # remote: ssh://docker@your-build-server
  
  # Build arguments passed to Docker
  args:
    RUBY_VERSION: 3.3.0
    
  # Secrets available during build (if needed)
  # secrets:
  #   - GITHUB_TOKEN
  #   - RAILS_MASTER_KEY
  
  # Cache configuration for faster builds
  cache:
    type: gha  # GitHub Actions cache (if building in CI)
    # Alternative: type: registry for registry-based caching

# SSH configuration - use a non-root user for better security
ssh:
  user: deploy  # Create this user on your servers
  # Alternatively, you can use 'root' for simplicity (less secure)
  # user: root

# Healthcheck configuration
healthcheck:
  path: /up
  port: 3000
  max_attempts: 10
  interval: 10s

# Optional: Use accessory services for external databases or Redis
# Uncomment and configure based on your scaling needs
accessories:
  # PostgreSQL database (for high-traffic deployments)
  # db:
  #   image: postgres:15
  #   host: REPLACE_WITH_DB_SERVER_IP
  #   port: "127.0.0.1:5432:5432"
  #   env:
  #     clear:
  #       POSTGRES_DB: homechat_production
  #       POSTGRES_USER: homechat
  #     secret:
  #       - POSTGRES_PASSWORD
  #   directories:
  #     - data:/var/lib/postgresql/data

  # Redis (for ActionCable in high-traffic setups)
  # redis:
  #   image: redis:7.0
  #   host: REPLACE_WITH_REDIS_SERVER_IP
  #   port: "127.0.0.1:6379:6379"
  #   directories:
  #     - data:/data
  #   cmd: redis-server --appendonly yes

# Boot configuration
boot:
  limit: 10 # Limit the number of old containers to keep
  wait: 5   # Seconds to wait between container starts
